<!doctype html>
<html lang="en">
<head>
    <title>Les types alg√©briques pour les langages orient√©s objet</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="alternate" type="application/rss+xml" title="Sadraskol's blog" href="https://sadraskol.com/feed">
    <style>
        fieldset {
            border: 0;
            padding: 0;
            margin: 0;
        }

        a {
            color: hsl(345.52, 100.0%, 77.25%);
            text-decoration: none
        }

        a:hover {
            text-decoration: underline;
            cursor: pointer
        }

        img {
            max-width: 100%;
        }

        body {
            margin: 0 0 0 0;
            font-family: "Helvetica Neue", "Helvetica", "Arial", sans-serif;
            background-color: hsl(22.11, 65.52%, 94.31%);
            color: hsl(344.0, 9.2%, 31.96%)
        }

        strong {
            color: hsl(345.0, 13.33%, 17.65%)
        }

        header {
            display: flex;
            flex-direction: row;
            justify-content: space-between;
            color: hsl(345.0, 13.33%, 17.65%)
        }

        header nav {
            padding-top: 1.0em;
            padding-bottom: 1.0em
        }

        .container {
            max-width: 900px;
            margin: 0 auto 0 auto;
            padding: 0 1em 0 1em;
        }

        figure img {
            display: block;
            margin: 0 auto 0.5em auto;
        }

        figure figcaption {
            text-align: center;
        }

        code {
            background-color: #fffffe;
        }

        pre code {
            background-color: #fffffe;
            overflow-x: auto;
            padding: 0.5em 0.5em 0.5em 0.5em;
            display: block;
        }

        blockquote {
            margin: 0 0 0 0;
            padding: 0.5em 1.5em 0.5em 3em;
            position: relative;
        }

        blockquote::before {
            content: "\201C";
            color: hsl(345.52, 100.0%, 77.25%);
            position: absolute;
            left: 0;
            font-size: 100px;
            line-height: 1;
        }

        .post-item {
            margin: 1.0em 0 0 0
        }

        .post-item:last-child {
            margin-bottom: 1.0em
        }

        .post-item__actions {
            display: flex;
            flex-direction: row;
            margin: 0 0 0 0;
            padding: 3.0px 0 0 0;
            list-style-type: none
        }

        .post-item__actions__item {
            position: relative;
            display: block;
            padding: 0 30.0px 0 0
        }

        .index-item {
            display: flex;
            margin: 1.0em 0 0 0;
        }
        .index-item:last-child {
            margin-bottom: 1.0em
        }
        .index-item_datetime {
            position: relative;
            display: block;
            padding: 0 30.0px 0 0;
            flex-basis: 8em;
            flex-shrink: 0;
        }

        .post-item__actions__item form button {
            background: none !important;
            border: none;
            padding: 0 !important;
            text-decoration: none;
            font: inherit;
            color: hsl(345.52, 100.0%, 77.25%);
        }

        .post-item__actions__item form button:hover {
            text-decoration: underline;
            cursor: pointer
        }

        #editor-content__textarea {
            width: 100%;
            height: 400px;
            padding: 1em;
            margin-bottom: 1em;
            display: block;
            resize: vertical;
        }

        .back-link {
            display: block;
            margin-bottom: 1em;
        }

        table th {
          text-align: center;
          padding: 8px 8px;
        }
        
        table td {
          text-align: center;
          padding: 8px 8px;
        }
        
        table tr {
          border-bottom: solid 1px #aaa;
        }

        table {
          border-collapse: collapse;
        }

        /* Github gist style from highlight js */
        .h-comment,
        .h-meta {
            color: #969896
        }

        .h-variable,
        .h-template-variable,
        .h-strong,
        .h-emphasis,
        .h-quote {
            color: #df5000
        }

        .h-keyword,
        .h-selector-tag,
        .h-type {
            color: #d73a49
        }

        .h-literal,
        .h-symbol,
        .h-bullet,
        .h-attribute {
            color: #0086b3
        }

        .h-section,
        .h-name {
            color: #63a35c
        }

        .h-tag {
            color: #333333
        }

        .h-title,
        .h-attr,
        .h-selector-id,
        .h-selector-class,
        .h-selector-attr,
        .h-selector-pseudo {
            color: #6f42c1
        }

        .h-addition {
            color: #55a532;
            background-color: #eaffea
        }

        .h-deletion {
            color: #bd2c00;
            background-color: #ffecec
        }

        .h-number {
            color: #005cc5
        }

        .h-string {
            color: #032f62
        }
    </style>
</head>
<body>
<div>
    <header class="container">
        <h1><a href="/">Sadraskol</a></h1>
    </header>
    <div class="container">
        
<h2>Les types alg√©briques pour les langages orient√©s objet</h2>
<time>02 February 2018</time>
<p>On pourrait renommer les languages fonctionnels (√† l'exception d'Erlang, mais c'est une autre histoire) des languages alg√©briques √† tel point que les structures alg√©briques sont leur outil de base. Nous allons essayer de montrer les analogies que ces structures ont avec les outils qui nous sont offerts dans les languages orient√©s objets et comment la r√©flexion en types alg√©briques permet de simplifier la mod√©lisation de nos probl√®mes.</p>
<h2>Les types sommes</h2>
<p>Vous connaissez certainement d√©j√† les types sommes : c'est le nom savant des √©numerations. Vous savez ce qu'on utilise en Java pour d√©signer les m√©thodes Http ?</p>
<pre><code class="language-java"><span class="h-keyword">public</span> enum HttpMethod {
	DELETE, GET, HEAD, OPTIONS, PATCH, POST, PUT, TRACE
}
</code></pre>
<p>Cette structure est assez simple, alors pourquoi la nommer avec une op√©ration alg√©brique comme la somme ? Qu'est-ce qu'on somme ici ? On parle de somme car on ajoute les possibilit√©s. Ici le type <code>HttpMethod</code> est la somme de ses valeurs possibles (<code>DELETE</code>, <code>HEAD</code>, etc.) : 8. On parle de Cardinalit√© pour exprimer ce nombre. On dit que le Cardinal de l'ensemble <code>HttpMethod</code> est 8. On reviendra sur ce concept plus tard.</p>
<p>Les √©num√©rations ne sont pourtant pas beaucoup utilis√©es en Java et malgr√© leurs propri√©t√©s int√©ressantes (pas de garbage collection, pas de probl√®me d'instantiation ou utilisation dans les switch, etc.) elles ne sont pas importantes dans les patrons de conceptions. Alors comment ce type pourrait-il √™tre central dans un autre language ? Voyons ce qu'est un type produit avant de r√©pondre √† cette question.</p>
<h2>Les types produits</h2>
<p>Un type produit est aussi tr√®s familier. Il correspond √† la r√©union de deux types. Si une personne est d√©fini par son nom et son √¢ge, on dira qu'il est le produit de ces deux types :</p>
<pre><code class="language-java"><span class="h-keyword">public</span> <span class="h-keyword">class</span> Person {
  <span class="h-keyword">private</span> final String name;
  <span class="h-keyword">private</span> final int age;
}
</code></pre>
<p>On parle de produit dans ce cas, car on peut avoir autant d'instance de <code>Person</code> qu'il y a de noms multipli√© par le nombre d'ages possibles. Dans ce cas, il s'agit d'une multiplication d'infini. Vu ce cardinal, il est impossible de pr√©voir tous les cas. C'est pourtant le type que le language nous engage le plus √† utiliser. C'est que ce type permet d'englober toutes les possibilit√©s dans une seule structure.</p>
<p>Est-il possible de restreindre le nombre de valeurs possibles tout en profitant de la mod√©lisation de domaine complexe que permet les types produits ?</p>
<h2>Les types alg√©briques</h2>
<p>Les beaucoup de <a href="https://en.wikipedia.org/wiki/Algebraic_data_type#Programming_languages_with_algebraic_data_types">languages</a> permettent d'utiliser une composition des types sommes et produits pour combiner les avantages des deux. Construisons un type qui mod√©lise un cas concret, </p>
<pre><code class="language-haskell"><span class="h-keyword">data</span> Maybe a = Nothing | Just a

getHttpHeader = Just Get -- Maybe HttpMethod
noHttpHeader = Nothing -- Not available
</code></pre>
<p>Si l'on tente de calculer le cardinal de ce type alg√©brique, on voit que les valeurs possibles pour ce type sont : <code>1 + 1 * C(a)</code>, <code>C(a)</code> √©tant le cardinal du type <code>a</code>. La notion de somme et de produit transparait directement dans le calcul du cardinal. Dans le cas o√π <code>a</code> est un <code>HttpMethod</code>, <code>C(Maybe HttpMethod) == 8</code>. Ce qui est int√©ressant dans cette approche, c'est l'exhaustivit√© des types repr√©sent√©s. Par exemple, il est possible de repr√©senter le score d'un point au tennis avec le type suivant :</p>
<pre><code class="language-haskell"><span class="h-keyword">data</span> Point = Zero | Fifteen | Thirty

<span class="h-keyword">data</span> Player = Player1 | Player2

<span class="h-keyword">data</span> GameScore
  = Score Point Point
  | GamePoint Player Point
  | Deuce
  | Advantage Player
  | Game Player
</code></pre>
<p>On pourrai montrer que le type <code>GameScore</code> impl√©mente l'ensemble des scores possible pour un point de tennis. On peut m√™me trivialement calculer l'ensemble des valeurs possibles :</p>
<pre><code>C(GameScore) == C(Point) * C(Point) + C(Player) * C(Point) + 1 + C(Player) + C(Player)
C(GameScore) == 3 * 3 + 2 * 3 + 1 + 2 + 2
C(GameScore) == 20
</code></pre>
<p>Il y a exactement 20 valeurs possibles (le code qui impl√©mente le comportement est √† la charge du lecteur üí™). √ätre capable de mod√©liser nos probl√®mes avec des types alg√©briques a l'√©norme avantage de demander √† ne r√©soudre que des valeurs possibles. Pas besoin de soucier des cas o√π il y aurait un score de <code>34 - 70</code> ou un score n√©gatif. Si Haskell, et d'autres languages, permettent de simplement d'exprimer ces cas, comment utiliser ces outils dans un language comme Java ? Voyons cela ensemble.</p>
<h2>Les types alg√©briques en Java</h2>
<p>Il y a plusieurs alternatives pour impl√©menter correctement des types alg√©briques. Java n'offre pas d'outils de base pour les repr√©senter, mais on peut utiliser un type purement produits avec une seule classe comme ceci :</p>
<pre><code class="language-java"><span class="h-keyword">class</span> GameScore {
  <span class="h-keyword">private</span> final int scorePlayer1;
  <span class="h-keyword">private</span> final int scorePlayer2;
  <span class="h-keyword">private</span> final GameStage stage;

  enum GameStage {
    Score, GamePoint, Deuce, Advantage, Game
  }
}
</code></pre>
<p>Le gros d√©savantage de ce genre d'approche (j'ai un peu exagg√©r√© l'exemple, on aurait pu utiliser des classes plus fines) est facilement rep√©rable √† partir d'un calcul de cardinal : <code>C(GameScore) = C(int) * C(int) * 5</code>. Dans ce cas, <code>C(GameScore)</code> est largement sup√©rieur au cas nominatif. De plus, il est de la responsabilit√© des m√©thodes manipulant ce type de ne pas se retrouver avec une valeur <code>(Score, 40, 40)</code> alors que c'est une valeur <code>Deuce</code> qui est attendue. Et puis que faire si on se retrouver dans la valeur <code>(Advantage, 15, 15)</code>, bref la complexit√© de cette impl√©mentation est, √† minima, dangereuse.</p>
<h3>Restreindre les valeurs possibles</h3>
<p>Pour r√©soudre cela, nous allons limiter les valeurs possibles. Dans un premier temps, on peut impl√©menter les √©num√©rations simples que l'on a pr√©sent√©es en Haskell :</p>
<pre><code class="language-java">enum Player { PLAYER_1, PLAYER_2 }
enum Score { Zero, Fifteen, Thirty }
</code></pre>
<p>Il nous reste quand m√™me le cas de l'impl√©mentation du score √† r√©soudre. Pour cela, on va utiliser l'outil de base des languages orient√©s objets : le polymorphisme ! Une impl√©mentation d'interface pour chaque constructeur de valeur :</p>
<pre><code class="language-java"><span class="h-keyword">public</span> <span class="h-keyword">class</span> Score <span class="h-keyword">implements</span> GameScore {
  <span class="h-keyword">private</span> final Score scorePlayer1;
  <span class="h-keyword">private</span> final Score scorePlayer2;
}
<span class="h-keyword">public</span> <span class="h-keyword">class</span> GamePoint <span class="h-keyword">implements</span> GameScore {
  <span class="h-keyword">private</span> final Player gamePointPlayer;
  <span class="h-keyword">private</span> final Score otherPlayerScore;
}
<span class="h-keyword">public</span> <span class="h-keyword">class</span> Deuce <span class="h-keyword">implements</span> GameScore {}
<span class="h-keyword">public</span> <span class="h-keyword">class</span> Advantage <span class="h-keyword">implements</span> GameScore {
  <span class="h-keyword">public</span> final Player forPlayer;
}
<span class="h-keyword">public</span> <span class="h-keyword">class</span> Game <span class="h-keyword">implements</span> GameScore {
  <span class="h-keyword">public</span> final Player forPlayer;
}
</code></pre>
<p>Cette impl√©mentation se rapproche tr√®s proche de l'impl√©mentation en Haskell. On pourrait penser que son cardinal est la m√™me. On a utilis√© les m√™mes constructeur avec les m√™mes valeurs ! Or ce n'est pas le cas, car Java a une valeur qui est difficile √† √©viter lors de l'impl√©mentation d'une classe : la valeur <code>null</code>. Si l'on explicite cette impl√©mentation en Haskell, elle ressemblerait plut√¥t √† √ßa :</p>
<pre><code class="language-haskell"><span class="h-keyword">data</span> Player = Player1 | Player2 | NullPlayer
<span class="h-keyword">data</span> GameScore
  = Score Point Point
  | GamePoint Player Point
  | Deuce
  | Advantage Player
  | Game Player
  | NullGameScore
-- etc.
</code></pre>
<p>Au lieu d'un cardinal du type alg√©brique <code>GameScore</code> : <code>C(GameScore) = 20</code>, on se retrouve avec <code>C(GameScore | Java) = 36</code>. Il y a 16 valeurs limites pour lesquels il va falloir se pr√©munir. Il existe des strat√©gies pour mitiger ce probl√®me : on peut ignorer ces cas et risquer des <code>NullPointerException</code>, les pr√©venir avec des <code>checkNotNull</code>, etc. Aucune solution n'est meilleure qu'une autre et il faut faire avec, car c'est le language lui-m√™me (et pas notre impl√©mentation) qui produit des valeurs limites de nos types alg√©briques.</p>
<h2>Conclusion</h2>
<p>Les types alg√©briques sont un outil tr√®s efficace pour limiter les valeurs pour un type et donc all√©ger la charge mentale lors du d√©veloppement d'une fonctionnalit√©. Les languages sont un auxiliaire √† l'habilit√© du d√©veloppeur et c'est de notre devoir de leur demander de coller au plus proche de ce que l'on souhaite exprimer.</p>

<div>
    <ul class="post-item__actions">
        <li class="post-item__actions__item"><a class="back-link" href="&#x2f;">All posts</a></li>
        <li class="post-item__actions__item"><a href="https://twitter.com/sadraskol">Twitter</a></li>
    </ul>
</div>

    </div>
</div>
</body>
</html>